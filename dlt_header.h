#ifndef __AUTO_OS_MIDDLEWARE_DLT_HEADER_H__
#define __AUTO_OS_MIDDLEWARE_DLT_HEADER_H__

namespace auto_os::middleware {

#define DLT_HDR_TYPE_USE_EXT_HEADER 0x80
#define DLT_HDR_TYPE_MSB_FIRST 0x40
#define DLT_HDR_TYPE_WITH_ECU_ID 0x20
#define DLT_HDR_TYPE_WITH_SESSION_ID 0x10
#define DLT_HDT_TYPE_WITH_TIMESTAMP 0x08

struct dlt_standard_header {
    /**
     * | UEH | MSBF | WEID | WTMS | VERS      |
     * | 0   | 1    | 2    | 3    | 5 | 6 | 7 |
     * 
     * UEH - use extended header
     * 1 - if extended header
     * 0 - if extended header is not used
     * 
     * MSBF - msb first
     * 
     * 1 - big endian format
     * 0 - little endian format
     * 
     * WEID - with extended id
     * 
     * 1 - the ecu id will be in standard header
     * 0 - the ecu id will not be contained in standard header
     * 
     * WSID - with session id
     * 
     * 1 - the session id field is contained in standard header
     * 0 - the session id field is not contained in standard header
     * 
     * WTMS - with timestamp
     * 
     * 1 - the timestamp is contained in standard header
     * 0 - the timestamp is not contained in standard header
     */
    uint8_t header_type;

    /**
     * 8 bit integer 0 - 255
     */
    uint8_t msg_counter;

    /**
     * 16 bit integer
     * 
     * sum of length of standard header +
     *        length of optional dlt extended header +
     *        length of the optional payload
     */
    uint16_t length;

    /**
     * ⌈If the ECU ID is shorter than four 8-bit ASCII characters, the 
     * remaining characters shall be filled with 0x00. ⌋
     */
    uint32_t ecu_id;

    /**
     *  Session ID is used to identify the source of a log or trace message
     */
    uint32_t session_id;
    /**
     * The time resolution is in 0.1 milliseconds
     */
    uint32_t timestamp;

    dlt_standard_header()
    {
        header_type = 0;
        msg_counter = 0;
        length = 0;
        ecu_id = 0;
        session_id = 0;
        timestamp = 0;
    }
    ~dlt_standard_header() { }

    int encode(uint8_t *buff, size_t buff_size, size_t &off);
    int decode(uint8_t *buff, size_t buff_size, size_t &off);
};

enum class dlt_extended_header_msg_type {
    eDLT_TYPE_LOG = 0x0, // DLT log message
    eDLT_TYPE_APP_TRACE, // DLT trace message
    eDLT_TYPE_NW_TRACE, // DLT network message
    eDLT_TYPE_CONTROL, // DLT control message
};

enum class dlt_extended_header_msg_type_info_log {
    eDLT_LOG_FATAL = 0x1, // Fatal system error
    eDLT_LOG_ERROR, // SWC error
    eDLT_LOG_WARN, // Correct behavior cannot be ensured
    eDLT_LOG_INFO, // Message of LogLevel type “Information
    eDLT_LOG_DEBUG, // Message of LogLevel type “Debug
    eDLT_LOG_VERBOSE, // Message of LogLevel type “Verbose”
};

enum class dlt_extended_header_msg_type_info_trace {
    eDLT_TRACE_VARIABLE = 0x1, // value of variable
    eDLT_TRACE_FUNCTION_IN, // Call of a function
    eDLT_TRACE_FUNCTION_OUT, // Return of a function
    eDLT_TRACE_STATE, // State of a State Machine
    eDLT_TRACE_VFB, // RTE events
};

enum class dlt_extended_header_msg_type_info_nw {
    eDLT_NW_TRACE_IPC, // Inter-Process-Communication
    eDLT_NW_TRACE_CAN, // CAN Communications bus
    eDLT_NW_TRACE_FLEXRAY, // FlexRay Communications bus
    eDLT_NW_TRACE_MOST, // Most Communications bus
    eDLT_NW_TRACE_ETHERNET, // Ethernet Communications bus
    eDLT_NW_TRACE_SOMEIP, // SOME/IP Communication
};

enum class dlt_extended_header_msg_type_info_ctrl {
    eDLT_CONTROL_REQUEST, // Request Control Message
    eDLT_CONTROL_RESPONSE, // Respond Control Message
};

struct dlt_extended_header {
    /**
     * | VERB | MSTP  | MTIN    |
     * | 0    | 1 2 3 | 4 5 6 7 |
     *
     * VERB - verbose mode
     * 
     * 1 - payload shall be transmitted in verbose mode
     * 0 - payload shall be transmitted in non verbose mode
     * 
     * MSTP - message type
     * 
     * type dlt_extended_header_msg_type
     * 
     * MTIN - messge type info
     * 
     * if eDLT_TYPE_LOG -> dlt_extended_header_msg_type_info_log
     * if eDLT_TYPE_APP_TRACE -> dlt_extended_header_msg_type_info_trace
     * if eDLT_TYPE_NW_TRACE -> dlt_extended_header_msg_type_info_nw
     * if eDLT_TYPE_CONTROL -> dlt_extended_header_msg_type_info_ctrl
     */
    uint8_t message_info;

    /**
     * Number of Arguments represents the number of consecutive parameters in the 
     * payload segment of one Dlt message. 
     */
    uint8_t number_of_args;

    /**
     * The Application ID field (APID) shall be a 32-bit field interpreted 
     * as four 8-bit ASCII characters.
     */
    uint32_t app_id;

    /**
     * user defined ID to logically group DLT messages generated by an application
     */
    uint32_t context_id;

    int encode(uint8_t *buff, size_t buff_size, size_t &off);
    int decode(uint8_t *buff, size_t buff_size, size_t &off);
};

struct dlt_header {
    dlt_standard_header std_hdr;
    dlt_extended_header ext_hdr;

    int encode(uint8_t *buff, size_t buff_size, size_t &off);
    int decode(uint8_t *buff, size_t buff_size, size_t &off);
};

}

#endif

